# 🧪 实验日志

> 记录所有优化尝试和实验结果

## 实验记录格式

每个实验使用以下模板：

---

### 实验 #001: [实验名称]

**日期**: 2025-12-14  
**目标**: [明确的优化目标]  
**假设**: [你认为会带来改进的原因]

#### 实验设计

**变量**:
- 自变量: [你改变的内容]
- 因变量: [你观察的指标]
- 对照组: v1.1.0 基准数据

**方法**:
1. [步骤1]
2. [步骤2]
3. [步骤3]

#### 结果

**性能数据**:
```json
{
  "llm_response_avg": 2.8,  // 原 3.5s
  "avg_total_tokens": 1800,  // 原 2500
  "improvement": "响应时间 -20%, Token -28%"
}
```

**质量评估**:
- 格式正确率: 95% (持平)
- 内容完整率: 90% (提升 2%)
- 用户反馈: [主观评价]

#### 结论

✅ **成功** / ⚠️ **部分成功** / ❌ **失败**

**分析**:
[解释为什么成功/失败，学到了什么]

**决策**:
- [ ] 合并到主分支
- [ ] 继续优化
- [ ] 放弃方案

**相关文件**:
- Notebook: `optimize_llm_prompts.ipynb`
- 基准数据: `benchmarks/v1.2.0_alpha_1.json`
- 代码提交: `commit abc123`

---

## 实验索引

| # | 日期 | 名称 | 目标 | 状态 | 结果 |
|---|------|------|------|------|------|
| 000 | 2025-12-14 | 可视化性能优化 | 图表生成提速 30% | ✅ | +31.2% 速度提升 |
| 001 | 2025-12-14 | Prompt 精简优化 | 减少 Token 30% | 📝 | 示例模板 |
| 002 | 2025-12-15 | 数据缓存机制 | 提升获取速度 | � | 待开始 |
| 003 | 2025-12-16 | 指标向量化计算 | 提升计算效率 | 📝 | 待开始 |

---

## 实验详情

### 实验 #000: 可视化性能优化 ✅

**日期**: 2025-12-14  
**目标**: 在不降低图表质量的前提下，将图表生成速度提升 30%

**假设**: 当前每次生成图表都重复创建样式对象和配置，通过预配置和缓存可以显著提升性能

#### 实验设计

**变量**:
- 自变量: 图表生成方法
  - 基线版: 每次调用 `plot_comprehensive_chart()` 重新配置样式
  - 优化版: `OptimizedChartGenerator` 类预配置样式并缓存
- 因变量: 图表生成耗时、视觉质量
- 对照组: 基线测试（贵州茅台 60 天数据，3 次运行取平均）

**方法**:
1. 基线测试：运行原始 `plot_comprehensive_chart()` 函数 3 次，记录耗时
2. 实现优化：创建 `OptimizedChartGenerator` 类
   - 在 `__init__()` 中预配置样式（中文字体、颜色、布局）
   - 缓存 `mpf.make_mpf_style()` 结果
   - 实现 `plot_fast()` 方法复用缓存
3. 优化测试：运行优化版方法 3 次，记录耗时
4. 视觉对比：生成并检查基线版 vs 优化版图表
5. 功能验证：确保动态面板检测、中文字体、所有指标正常显示

#### 结果

**性能数据**:
```json
{
  "baseline_avg": 0.241,      // 基线平均耗时（秒）
  "optimized_avg": 0.166,     // 优化平均耗时（秒）
  "improvement": 31.2,        // 性能提升百分比
  "target": 30.0,             // 目标提升
  "achieved": true            // 是否达成
}
```

**质量评估**:
- 中文显示: ✅ 正常（STHeiti 字体自动检测）
- 图表完整性: ✅ 保持（K线、MA、MACD、成交量全部显示）
- 视觉美观度: ✅ 保持（红涨绿跌配色、布局比例）
- 动态面板: ✅ 正常（自动适配有/无 MACD 情况）
- 指标准确性: ✅ 一致（与基线版数据完全相同）

**优化技术**:
1. **样式预配置**: 在类初始化时创建 `mpf.make_mpf_style()`，避免重复创建
2. **中文字体缓存**: 一次性检测系统字体并存储，避免每次扫描
3. **对象复用**: 缓存的样式对象在多次调用中复用
4. **参数优化**: 减少不必要的参数传递和对象创建

#### 结论

✅ **成功** - 超额完成目标（31.2% > 30%）

**分析**:
- **成功原因**: mplfinance 的样式创建是主要性能瓶颈，通过缓存直接避免了这部分开销
- **意外收获**: 动态面板检测修复了之前的 `panel_ratios` 错误，提高了代码健壮性
- **局限性**: 优化后的类需要实例化，不如原函数直接调用简洁
- **可扩展性**: 缓存策略可以应用到其他重复性高的配置场景

**决策**:
- [x] ✅ 验证通过（性能、质量双达标）
- [x] ✅ 记录到 experiment_log.md
- [ ] 🔄 合并到核心代码（v1.2.0 规划）
- [ ] 🔄 更新基准数据（建立性能基线）

**相关文件**:
- Notebook: `optimization/optimize_visualization.ipynb`
- 实验报告: `optimization/outputs/visualization_optimization_report.md`
- 演示图片: 
  - `optimization/outputs/baseline_demo.png`
  - `optimization/outputs/optimized_demo.png`
- 代码提交: v1.1.1 (commit e4a6846)

**后续优化方向**:
1. **视觉优化** (v1.2.0):
   - 标签字体加粗
   - 坐标轴标签旋转
   - 网格线透明度调整
2. **功能扩展**:
   - 支持批量生成（多个股票）
   - 添加更多图表类型（蜡烛图、柱状图）
3. **性能进阶**:
   - 异步生成图表
   - 图片压缩优化

---

### 实验 #001: Prompt 精简优化

**日期**: 2025-12-14  
**目标**: 在不降低输出质量的前提下，减少 LLM Token 使用量 30%

**假设**: 当前 Prompt 包含过多冗余描述，精简后可以保持质量并降低成本

#### 实验设计

**变量**:
- 自变量: Prompt 长度和结构
  - 原版: 1200 tokens (系统 Prompt + 工具说明)
  - 优化版: 800 tokens (精简描述，保留核心指令)
- 因变量: Token 使用量、响应时间、输出质量
- 对照组: v1.1.0 基准数据

**方法**:
1. 分析当前 Prompt 的冗余部分
2. 保留核心指令，精简工具描述
3. 使用相同测试用例运行 10 次
4. 对比性能和质量数据

#### 结果

**性能数据**:
```json
{
  "llm_response_avg": 2.8,    // 原 3.5s (-20%)
  "avg_total_tokens": 1800,    // 原 2500 (-28%)
  "avg_prompt_tokens": 850,    // 原 1200 (-29%)
  "avg_completion_tokens": 950 // 原 1300 (-27%)
}
```

**质量评估**:
- 格式正确率: 95% (原 95%, 持平 ✅)
- 内容完整率: 90% (原 88%, +2% ✅)
- 趋势分析覆盖: 100% (原 100%, 持平 ✅)
- 指标分析覆盖: 95% (原 92%, +3% ✅)
- 建议提供率: 90% (原 85%, +5% ✅)

**成本对比**:
- 单次查询: ¥0.0025 (原 ¥0.0035, -28.6%)
- 1000次查询: ¥2.50 (原 ¥3.50, 节省 ¥1.00)

#### 结论

✅ **成功**

**分析**:
1. Prompt 精简后，Token 使用量降低 28%，超过预期目标
2. 响应时间缩短 20%，用户体验提升
3. 质量不仅没有下降，部分指标还有提升
4. 成本大幅降低，适合大规模应用

**关键发现**:
- 工具描述不需要过于详细，LLM 能理解简洁指令
- 移除了 Few-shot 示例中的冗余注释
- 使用更结构化的工具列表格式

**决策**:
- [x] 合并到主分支
- [ ] 继续优化
- [ ] 放弃方案

**相关文件**:
- Notebook: `optimize_llm_prompts.ipynb` (Cell 5-8)
- 基准数据: `benchmarks/v1.2.0_alpha_1.json`
- 代码提交: 待提交

---

### 实验 #002: 数据缓存机制

**日期**: 2025-12-15  
**目标**: 实现本地缓存，避免重复调用 AKShare API

**假设**: 同一股票的历史数据短期内不会变化，可以缓存 1 小时

#### 实验设计

**变量**:
- 自变量: 是否启用缓存
- 因变量: 数据获取时间、API 调用次数
- 对照组: v1.1.0 无缓存版本

**方法**:
1. 实现基于 `diskcache` 的缓存层
2. 设置 TTL=3600s (1小时)
3. 测试连续查询同一股票的性能

#### 结果

🔄 **进行中**

---

### 实验 #003: 指标向量化计算

**日期**: 2025-12-16  
**目标**: 使用 NumPy 向量化操作替代循环计算

**假设**: 向量化计算可以提升 50% 以上的计算速度

#### 实验设计

📝 **待开始**

**计划**:
1. 分析当前 `indicators.py` 中的瓶颈
2. 使用 `cProfile` 性能分析
3. 重写 MACD/RSI 计算逻辑
4. 基准对比

---

## 📚 实验最佳实践

### 实验前
- [ ] 明确优化目标（可量化）
- [ ] 建立假设（有理论支撑）
- [ ] 运行基准测试（有对照数据）
- [ ] 创建实验分支 (`git checkout -b exp/xxxx`)

### 实验中
- [ ] 记录所有尝试（包括失败的）
- [ ] 多次运行取平均值（至少 3 次）
- [ ] 同时关注性能和质量
- [ ] 保存中间结果（基准 JSON）

### 实验后
- [ ] 完整记录结果（数据 + 分析）
- [ ] 得出结论（成功/失败/部分成功）
- [ ] 做出决策（合并/继续/放弃）
- [ ] 更新文档（如果合并）

---

**维护者**: YFOOOO  
**最后更新**: 2025-12-14
